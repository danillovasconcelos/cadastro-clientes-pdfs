-- 0) Extensão
create extension if not exists pgcrypto;

-- 1) Garanta que a tabela services tem as colunas esperadas
alter table public.services add column if not exists company_id uuid;
alter table public.services add column if not exists type_id    int8;
alter table public.services add column if not exists owner_name text;
alter table public.services add column if not exists owner_cpf  text;
alter table public.services add column if not exists owner_address text;
alter table public.services add column if not exists site_address  text;
alter table public.services add column if not exists area_m2 numeric default 0;
alter table public.services add column if not exists protocol text;
alter table public.services add column if not exists status text default 'draft';
alter table public.services add column if not exists created_at timestamptz default now();
alter table public.services add column if not exists updated_at timestamptz default now();

-- 1.1) Constraint de status (se não existir)
do $$
begin
  if not exists (
    select 1 from pg_constraint
     where conname = 'services_status_check'
  ) then
    alter table public.services
      add constraint services_status_check
      check (status in ('draft','under_review','corrections_requested','concluded'));
  end if;
end$$;

-- 1.2) Chave primária se por acaso não existir (ajuste se já tiver PK)
do $$
begin
  if not exists (
    select 1 from pg_constraint
     where conrelid = 'public.services'::regclass
       and contype = 'p'
  ) then
    alter table public.services
      add column if not exists id uuid default gen_random_uuid(),
      add primary key (id);
  end if;
end$$;

-- 1.3) FKs (só adiciona se não existirem)
do $$
begin
  if not exists (
    select 1 from pg_constraint where conname = 'services_company_id_fkey'
  ) then
    alter table public.services
      add constraint services_company_id_fkey
      foreign key (company_id) references public.companies(id) on delete cascade;
  end if;

  if not exists (
    select 1 from pg_constraint where conname = 'services_type_id_fkey'
  ) then
    alter table public.services
      add constraint services_type_id_fkey
      foreign key (type_id) references public.service_types(id);
  end if;
end$$;

-- 2) Trigger para atualizar updated_at
create or replace function public.fn_touch_updated_at()
returns trigger language plpgsql as $$
begin
  new.updated_at := now();
  return new;
end$$;

do $$
begin
  if not exists (
    select 1 from pg_trigger where tgname = 'trg_services_touch_updated_at'
  ) then
    create trigger trg_services_touch_updated_at
      before update on public.services
      for each row execute function public.fn_touch_updated_at();
  end if;
end$$;

-- 3) Ativa RLS
alter table public.services enable row level security;

-- 4) (Re)cria políticas de forma idempotente
-- Remova políticas antigas com nomes diferentes, se necessário
-- (seguro: só remove se existirem com esses nomes)
do $$
begin
  if exists (select 1 from pg_policies where schemaname='public' and tablename='services' and policyname='services_select') then
    drop policy services_select on public.services;
  end if;
  if exists (select 1 from pg_policies where schemaname='public' and tablename='services' and policyname='services_insert') then
    drop policy services_insert on public.services;
  end if;
  if exists (select 1 from pg_policies where schemaname='public' and tablename='services' and policyname='services_update') then
    drop policy services_update on public.services;
  end if;
  if exists (select 1 from pg_policies where schemaname='public' and tablename='services' and policyname='services_delete') then
    drop policy services_delete on public.services;
  end if;

  create policy services_select on public.services
    for select to authenticated
    using (
      exists (
        select 1 from public.company_members m
        where m.company_id = services.company_id
          and m.user_id = auth.uid()
      )
    );

  create policy services_insert on public.services
    for insert to authenticated
    with check (
      exists (
        select 1 from public.company_members m
        where m.company_id = services.company_id
          and m.user_id = auth.uid()
      )
    );

  create policy services_update on public.services
    for update to authenticated
    using (
      exists (
        select 1 from public.company_members m
        where m.company_id = services.company_id
          and m.user_id = auth.uid()
      )
    );

  create policy services_delete on public.services
    for delete to authenticated
    using (
      exists (
        select 1 from public.company_members m
        where m.company_id = services.company_id
          and m.user_id = auth.uid()
      )
    );
end$$;

-- 5) (Opcional) service_documents (se ainda não existir) + RLS
create table if not exists public.service_documents (
  service_id uuid not null references public.services(id) on delete cascade,
  document_type_id int8 not null references public.document_types(id),
  file_path text not null,
  uploaded_at timestamptz not null default now(),
  primary key (service_id, document_type_id)
);

alter table public.service_documents enable row level security;

do $$
begin
  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='service_documents' and policyname='sd_select'
  ) then
    create policy sd_select on public.service_documents
      for select to authenticated
      using (
        exists (
          select 1 from public.services s
           join public.company_members m on m.company_id = s.company_id
          where s.id = service_documents.service_id
            and m.user_id = auth.uid()
        )
      );
  end if;

  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='service_documents' and policyname='sd_upsert'
  ) then
    create policy sd_upsert on public.service_documents
      for insert to authenticated
      with check (
        exists (
          select 1 from public.services s
           join public.company_members m on m.company_id = s.company_id
          where s.id = service_documents.service_id
            and m.user_id = auth.uid()
        )
      );
  end if;

  if not exists (
    select 1 from pg_policies where schemaname='public' and tablename='service_documents' and policyname='sd_delete'
  ) then
    create policy sd_delete on public.service_documents
      for delete to authenticated
      using (
        exists (
          select 1 from public.services s
           join public.company_members m on m.company_id = s.company_id
          where s.id = service_documents.service_id
            and m.user_id = auth.uid()
        )
      );
  end if;
end$$;
