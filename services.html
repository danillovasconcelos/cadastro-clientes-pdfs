<script>
  /*********************************
   * SUPABASE — bootstrap do cliente
   *********************************/
  const SB_URL = localStorage.getItem('SUPABASE_URL') || sessionStorage.getItem('SUPABASE_URL');
  const SB_KEY = localStorage.getItem('SUPABASE_ANON_KEY') || sessionStorage.getItem('SUPABASE_ANON_KEY');

  if (!SB_URL || !SB_KEY) {
    document.getElementById('alertConn').style.display = 'block';
  }

  const sb = (SB_URL && SB_KEY) ? window.supabase.createClient(SB_URL, SB_KEY) : null;

  // Empresa atual gravada na index
  const COMPANY_ID =
    localStorage.getItem('COMPANY_ID') ||
    sessionStorage.getItem('COMPANY_ID') ||
    new URLSearchParams(location.search).get('company_id'); // fallback opcional

  /*********************************
   * Helpers
   *********************************/
  const $ = sel => document.querySelector(sel);
  const fmt = new Intl.DateTimeFormat('pt-BR', { dateStyle: 'short', timeStyle: 'short' });

  const statusLabel = (s) => {
    const map = {
      draft: ['Rascunho', 'warn'],
      under_review: ['Em análise', 'warn'],
      corrections_requested: ['Correções solicitadas', 'warn'],
      concluded: ['Concluído', 'ok']
    };
    const [txt, cls] = map[s] || [s, 'muted'];
    return `<span class="badge ${cls}">${txt}</span>`;
  };

  function toast(msg, type='info'){
    const c = document.createElement('div');
    c.textContent = msg;
    c.style.cssText = `position:fixed; right:1rem; bottom:1rem; padding:.6rem .8rem; border-radius:.5rem; color:#fff; z-index:9999;`;
    c.style.background = type==='err' ? '#d33' : (type==='ok' ? '#0a7' : '#333');
    document.body.appendChild(c);
    setTimeout(()=>c.remove(), 3600);
  }

  /*********************************
   * Estado da tela
   *********************************/
  let currentService = null;   // objeto completo do serviço carregado
  let requiredDocs = [];       // docs obrigatórios do tipo

  // Campos
  const selType   = $('#selType');
  const ownerName = $('#ownerName');
  const ownerCpf  = $('#ownerCpf');
  const ownerAddr = $('#ownerAddr');
  const siteAddr  = $('#siteAddr');
  const areaM2    = $('#areaM2');
  const proto     = $('#proto');
  const statusTxt = $('#statusTxt');

  const btnDraft  = $('#btnDraft');
  const btnSave   = $('#btnSave');
  const btnSendDocs = $('#btnSendDocs');
  const btnSubmit = $('#btnSubmit');
  const docsList  = $('#docsList');
  const cardDocs  = $('#cardDocs');
  const cardForm  = $('#cardForm');
  const tbody     = $('#tblServices tbody');

  /*********************************
   * Carregamentos iniciais
   *********************************/
  (async function init(){
    if (!sb) return;

    // Verifica empresa
    if (!COMPANY_ID) {
      toast('Empresa não definida. Selecione na tela inicial.', 'err');
    }

    // Carrega tipos de serviço
    const { data: types, error: e1 } = await sb
      .from('service_types')
      .select('id, name')
      .order('name');
    if (e1) {
      console.error(e1);
      toast('Erro ao carregar tipos de serviço', 'err');
    } else {
      selType.innerHTML = '<option value="">Selecione...</option>' +
        (types || []).map(t => `<option value="${t.id}">${t.name}</option>`).join('');
    }

    // Lista serviços do usuário/empresa
    await loadMyServices();
  })();

  /*********************************
   * Ações da UI
   *********************************/
  btnDraft.addEventListener('click', async () => {
    if (!sb) return;
    if (!COMPANY_ID) {
      toast('Defina a empresa na tela inicial.', 'err');
      return;
    }
    const typeId = selType.value;
    if (!typeId) {
      toast('Escolha o tipo de serviço.', 'err');
      return;
    }

    const payload = {
      company_id: COMPANY_ID,
      type_id: typeId,
      owner_name: ownerName.value?.trim() || null,
      owner_cpf: ownerCpf.value?.trim() || null,
      owner_address: ownerAddr.value?.trim() || null,
      site_address: siteAddr.value?.trim() || null,
      area_m2: areaM2.value ? Number(areaM2.value) : 0,
      status: 'draft'
    };
    console.log('[Criar/Salvar] payload:', payload);

    // Se já existir um serviço carregado, vira “Salvar alterações”
    if (currentService?.id) {
      const { data, error } = await sb.from('services')
        .update(payload).eq('id', currentService.id).select().single();
      if (error) { console.error(error); return toast('Erro ao salvar rascunho: ' + (error.message||''), 'err'); }
      currentService = data;
      toast('Rascunho salvo', 'ok');
      refreshForm();
      await loadRequiredDocs();
      return;
    }

    // Cria rascunho novo
    const { data, error } = await sb.from('services').insert(payload).select().single();
    if (error) {
      console.error('[INSERT services] error:', error);
      return toast('Erro ao criar rascunho: ' + (error.message || 'ver console'), 'err');
    }
    currentService = data;
    toast('Rascunho criado', 'ok');
    refreshForm();
    await loadRequiredDocs();
    await loadMyServices();
  });

  btnSave.addEventListener('click', async () => {
    if (!sb || !currentService?.id) return;
    const payload = {
      type_id: selType.value || null,
      owner_name: ownerName.value?.trim() || null,
      owner_cpf: ownerCpf.value?.trim() || null,
      owner_address: ownerAddr.value?.trim() || null,
      site_address: siteAddr.value?.trim() || null,
      area_m2: areaM2.value ? Number(areaM2.value) : 0,
    };
    const { data, error } = await sb.from('services')
      .update(payload).eq('id', currentService.id).select().single();
    if (error) { console.error(error); return toast('Erro ao salvar: ' + (error.message||''), 'err'); }
    currentService = data;
    toast('Alterações salvas', 'ok');
    refreshForm();
    await loadRequiredDocs();
    await loadMyServices();
  });

  btnSendDocs.addEventListener('click', async () => {
    if (!sb || !currentService?.id) return;

    const inputs = docsList.querySelectorAll('input[type=file]');
    if (!inputs.length) return toast('Nenhum campo de upload disponível.', 'err');

    const bucket = sb.storage.from('pdfs');
    const uploads = [];

    inputs.forEach(inp => {
      const file = inp.files?.[0];
      if (!file) return;
      if (file.type !== 'application/pdf') {
        return toast(`O arquivo "${file.name}" precisa ser PDF.`, 'err');
      }
      const docCode = inp.dataset.code; // veio do render
      const docId   = inp.dataset.docid;
      const path = `${COMPANY_ID}/${currentService.id}/${docCode}.pdf`;

      uploads.push(
        (async () => {
          const { error: upErr } = await bucket.upload(path, file, { upsert: true, contentType: 'application/pdf' });
          if (upErr) { console.error(upErr); throw upErr; }

          const { error: dbErr } = await sb.from('service_documents')
            .upsert({
              service_id: currentService.id,
              document_type_id: docId,
              file_path: path,
              uploaded_at: new Date().toISOString()
            }, { onConflict: 'service_id,document_type_id' });
          if (dbErr) { console.error(dbErr); throw dbErr; }
        })()
      );
    });

    try {
      await Promise.all(uploads);
      toast('Uploads salvos', 'ok');
      await loadRequiredDocs();
    } catch (e) {
      toast('Falha ao enviar algum documento', 'err');
    }
  });

  btnSubmit.addEventListener('click', async () => {
    if (!sb || !currentService?.id) return;

    const { data, error } = await sb.from('services')
      .update({ status: 'under_review', updated_at: new Date().toISOString() })
      .eq('id', currentService.id).select().single();
    if (error) { console.error(error); return toast('Erro ao enviar para análise: ' + (error.message||''), 'err'); }
    currentService = data;
    toast('Enviado para análise', 'ok');
    refreshForm();
    await loadMyServices();
  });

  /*********************************
   * Funções de tela/dados
   *********************************/
  async function loadMyServices() {
    if (!sb) return;
    const { data, error } = await sb
      .from('services')
      .select('id, status, protocol, created_at, service_types(name)')
      .eq('company_id', COMPANY_ID)     // <<< filtra pela empresa
      .order('created_at', { ascending: false });
    if (error) { console.error(error); return; }

    tbody.innerHTML = (data || []).map(s => `
      <tr>
        <td class="mono">${s.id}</td>
        <td>${s.service_types?.name || '-'}</td>
        <td>${statusLabel(s.status)}</td>
        <td class="mono">${s.protocol || '-'}</td>
        <td>${fmt.format(new Date(s.created_at))}</td>
        <td>
          <button class="secondary small" data-edit="${s.id}" ${!canEdit(s.status) ? 'disabled' : ''}>Editar</button>
        </td>
      </tr>
    `).join('');

    tbody.querySelectorAll('button[data-edit]').forEach(btn => {
      btn.addEventListener('click', () => loadServiceById(btn.dataset.edit));
    });
  }

  function canEdit(status){
    return ['draft','corrections_requested'].includes(status);
  }

  async function loadServiceById(id){
    if (!sb) return;
    const { data, error } = await sb.from('services').select('*').eq('id', id).single();
    if (error) { console.error(error); return toast('Erro ao carregar serviço', 'err'); }
    currentService = data;
    refreshForm();
    await loadRequiredDocs();
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  function refreshForm(){
    if (!currentService) {
      btnSave.disabled = true;
      proto.value = ''; statusTxt.value = '';
      docsList.innerHTML = ''; cardDocs.style.display = 'none';
      cardForm.classList.remove('lock');
      return;
    }
    selType.value   = currentService.type_id ?? '';
    ownerName.value = currentService.owner_name ?? '';
    ownerCpf.value  = currentService.owner_cpf ?? '';
    ownerAddr.value = currentService.owner_address ?? '';
    siteAddr.value  = currentService.site_address ?? '';
    areaM2.value    = Number(currentService.area_m2 ?? 0);
    proto.value     = currentService.protocol || '';
    statusTxt.value = currentService.status || '';

    const editable = canEdit(currentService.status);
    btnSave.disabled = !editable;
    btnSendDocs.disabled = !editable;
    btnSubmit.disabled = !editable;
    cardForm.classList.toggle('lock', !editable);

    cardDocs.style.display = 'block';
  }

  async function loadRequiredDocs(){
    if (!sb || !currentService?.type_id) return;

    let sel = 'document_type_id, document_types:document_type_id ( id, name, code )';
    const { data, error } = await sb
      .from('service_type_requirements')
      .select(sel)
      .eq('service_type_id', currentService.type_id);
    if (error) { console.error(error); return; }

    const { data: sent } = await sb
      .from('service_documents')
      .select('document_type_id, file_path, uploaded_at')
      .eq('service_id', currentService.id);

    requiredDocs = (data || []).map(r => ({
      id: r.document_types?.id || r.document_type_id,
      name: r.document_types?.name || '(sem nome)',
      code: r.document_types?.code || 'doc',
      sent: sent?.find(s => s.document_type_id === (r.document_types?.id || r.document_type_id)) || null
    }));

    docsList.innerHTML = requiredDocs.map(d => `
      <article>
        <header class="grid grid-3" style="align-items:center;">
          <strong>${d.name}</strong>
          <span class="mono small muted">código: ${d.code}</span>
          <span>${d.sent ? '<span class="badge ok">enviado</span>' : '<span class="badge warn">pendente</span>'}</span>
        </header>
        <input type="file" accept="application/pdf" data-code="${d.code}" data-docid="${d.id}" ${!canEdit(currentService.status) ? 'disabled' : ''}/>
        ${d.sent ? `<small class="muted">Último envio: ${fmt.format(new Date(d.sent.uploaded_at))}</small>` : ''}
      </article>
    `).join('');
  }
</script>
