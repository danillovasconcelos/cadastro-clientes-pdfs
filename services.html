<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Serviços — Usuário</title>

  <!-- Estilinho leve (pode trocar pelo seu) -->
  <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@2/css/pico.min.css">
  <style>
    body { --pico-font-size: 16px; }
    .muted { opacity: .7 }
    .badge { padding: .2rem .5rem; border-radius: .4rem; font-size: .8rem; }
    .ok{ background:#0ea; color:#012; }
    .warn{ background:#ffc107; color:#222; }
    .err{ background:#f66; color:#fff; }
    .grid{ display:grid; gap:1rem; }
    .grid-2{ grid-template-columns: 1fr 1fr; }
    .grid-3{ grid-template-columns: repeat(3,1fr); }
    .table-wrap{ overflow:auto; }
    .lock { opacity:.5; pointer-events:none; filter:grayscale(1); }
    input[type=file]{ padding:.4rem; }
    .small { font-size:.85rem }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>

  <!-- Supabase JS v2 -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
</head>
<body>
  <main class="container">
    <nav>
      <ul>
        <li><a href="./index.html">← Voltar</a></li>
      </ul>
      <ul>
        <li class="muted small">Se necessário, passe pela tela inicial para gravar <code>SUPABASE_URL</code> e <code>ANON_KEY</code> no navegador.</li>
        <li><a href="./analyst.html">Ir ao Painel do Analista</a></li>
      </ul>
    </nav>

    <hgroup>
      <h1>Serviços (Usuário)</h1>
      <p class="muted">Crie o rascunho, envie os PDFs obrigatórios e finalize para análise.</p>
    </hgroup>

    <!-- ALERTA DE CONEXÃO -->
    <article id="alertConn" class="err" style="display:none; padding:.8rem; border-radius:.5rem;">
      Configure <strong>SUPABASE_URL</strong> e <strong>ANON_KEY</strong> na tela inicial.
    </article>

    <!-- FORM RASCUNHO -->
    <article id="cardForm">
      <h3>Novo serviço</h3>
      <div class="grid grid-3">
        <label>Tipo de serviço
          <select id="selType"></select>
        </label>
        <label>Proprietário
          <input id="ownerName" placeholder="Nome completo" />
        </label>
        <label>CPF
          <input id="ownerCpf" placeholder="CPF" />
        </label>
      </div>

      <div class="grid grid-2">
        <label>Endereço do proprietário
          <input id="ownerAddr" placeholder="Endereço" />
        </label>
        <label>Endereço da obra
          <input id="siteAddr" placeholder="Endereço" />
        </label>
      </div>

      <div class="grid grid-3">
        <label>Área (m²)
          <input id="areaM2" type="number" min="0" value="0" />
        </label>
        <label>Protocolo
          <input id="proto" class="mono" placeholder="—" disabled />
        </label>
        <label>Status
          <input id="statusTxt" class="mono" placeholder="—" disabled />
        </label>
      </div>

      <footer>
        <button id="btnDraft">Criar rascunho</button>
        <button id="btnSave" class="secondary" disabled>Salvar alterações</button>
      </footer>
    </article>

    <!-- DOCS OBRIGATÓRIOS -->
    <article id="cardDocs" style="display:none;">
      <h3>Documentos obrigatórios</h3>
      <p class="muted small">Selecione o tipo e crie/salva o rascunho para liberar os uploads.</p>
      <div id="docsList" class="grid"></div>

      <footer>
        <button id="btnSendDocs" class="secondary">Enviar documentos</button>
        <button id="btnSubmit" class="contrast">Confirmar e Enviar</button>
      </footer>
    </article>

    <!-- MEUS SERVIÇOS -->
    <article>
      <h3>Meus serviços</h3>
      <div class="table-wrap">
        <table id="tblServices">
          <thead>
            <tr>
              <th>ID</th>
              <th>Tipo</th>
              <th>Status</th>
              <th>Protocolo</th>
              <th>Criado em</th>
              <th>Ações</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </article>
  </main>

  <script>
    /*********************************
     * SUPABASE — bootstrap do cliente
     *********************************/
    const SB_URL = localStorage.getItem('SUPABASE_URL') || sessionStorage.getItem('SUPABASE_URL');
    const SB_KEY = localStorage.getItem('SUPABASE_ANON_KEY') || sessionStorage.getItem('SUPABASE_ANON_KEY');

    if (!SB_URL || !SB_KEY) {
      document.getElementById('alertConn').style.display = 'block';
    }

    const sb = (SB_URL && SB_KEY) ? window.supabase.createClient(SB_URL, SB_KEY) : null;

    // Empresa atual (gravada na index). Ajuste a chave se usou outro nome.
    const CURRENT_COMPANY_ID =
      localStorage.getItem('CURRENT_COMPANY_ID') ||
      sessionStorage.getItem('CURRENT_COMPANY_ID') ||
      new URLSearchParams(location.search).get('company_id'); // fallback opcional

    /*********************************
     * Helpers
     *********************************/
    const $ = sel => document.querySelector(sel);
    const fmt = new Intl.DateTimeFormat('pt-BR', { dateStyle: 'short', timeStyle: 'short' });

    const statusLabel = (s) => {
      const map = {
        draft: ['Rascunho', 'warn'],
        under_review: ['Em análise', 'warn'],
        corrections_requested: ['Correções solicitadas', 'warn'],
        concluded: ['Concluído', 'ok']
      };
      const [txt, cls] = map[s] || [s, 'muted'];
      return `<span class="badge ${cls}">${txt}</span>`;
    };

    function toast(msg, type='info'){
      const c = document.createElement('div');
      c.textContent = msg;
      c.style.cssText = `position:fixed; right:1rem; bottom:1rem; padding:.6rem .8rem; border-radius:.5rem; color:#fff; z-index:9999;`;
      c.style.background = type==='err' ? '#d33' : (type==='ok' ? '#0a7' : '#333');
      document.body.appendChild(c);
      setTimeout(()=>c.remove(), 3600);
    }

    /*********************************
     * Estado da tela
     *********************************/
    let currentService = null;   // objeto completo do serviço carregado
    let requiredDocs = [];       // docs obrigatórios do tipo

    // Campos
    const selType   = $('#selType');
    const ownerName = $('#ownerName');
    const ownerCpf  = $('#ownerCpf');
    const ownerAddr = $('#ownerAddr');
    const siteAddr  = $('#siteAddr');
    const areaM2    = $('#areaM2');
    const proto     = $('#proto');
    const statusTxt = $('#statusTxt');

    const btnDraft  = $('#btnDraft');
    const btnSave   = $('#btnSave');
    const btnSendDocs = $('#btnSendDocs');
    const btnSubmit = $('#btnSubmit');
    const docsList  = $('#docsList');
    const cardDocs  = $('#cardDocs');
    const cardForm  = $('#cardForm');
    const tbody     = $('#tblServices tbody');

    /*********************************
     * Carregamentos iniciais
     *********************************/
    (async function init(){
      if (!sb) return;

      // Verifica empresa
      if (!CURRENT_COMPANY_ID) {
        toast('Empresa não definida. Selecione na tela inicial.', 'err');
      }

      // Carrega tipos de serviço
      const { data: types, error: e1 } = await sb.from('service_types').select('id, name').order('name');
      if (e1) {
        console.error(e1);
        toast('Erro ao carregar tipos de serviço', 'err');
      } else {
        selType.innerHTML = '<option value="">Selecione...</option>' +
          types.map(t => `<option value="${t.id}">${t.name}</option>`).join('');
      }

      // Lista serviços do usuário/empresa
      await loadMyServices();
    })();

    /*********************************
     * Ações da UI
     *********************************/
    btnDraft.addEventListener('click', async () => {
      if (!sb) return;
      if (!CURRENT_COMPANY_ID) {
        toast('Defina a empresa na tela inicial.', 'err');
        return;
      }
      const typeId = selType.value;
      if (!typeId) {
        toast('Escolha o tipo de serviço.', 'err');
        return;
      }

      const payload = {
        company_id: CURRENT_COMPANY_ID,
        type_id: typeId,
        owner_name: ownerName.value?.trim() || null,
        owner_cpf: ownerCpf.value?.trim() || null,
        owner_address: ownerAddr.value?.trim() || null,
        site_address: siteAddr.value?.trim() || null,
        area_m2: areaM2.value ? Number(areaM2.value) : 0,
        status: 'draft'
      };

      // Se já existir um serviço carregado, viramos “Salvar alterações”
      if (currentService?.id) {
        const { data, error } = await sb.from('services')
          .update(payload).eq('id', currentService.id).select().single();
        if (error) { console.error(error); return toast('Erro ao salvar rascunho', 'err'); }
        currentService = data;
        toast('Rascunho salvo', 'ok');
        refreshForm();
        await loadRequiredDocs();
        return;
      }

      // Cria rascunho novo
      const { data, error } = await sb.from('services').insert(payload).select().single();
      if (error) { console.error(error); return toast('Erro ao criar rascunho', 'err'); }
      currentService = data;
      toast('Rascunho criado', 'ok');
      refreshForm();
      await loadRequiredDocs();
      await loadMyServices();
    });

    btnSave.addEventListener('click', async () => {
      if (!sb || !currentService?.id) return;
      const payload = {
        type_id: selType.value || null,
        owner_name: ownerName.value?.trim() || null,
        owner_cpf: ownerCpf.value?.trim() || null,
        owner_address: ownerAddr.value?.trim() || null,
        site_address: siteAddr.value?.trim() || null,
        area_m2: areaM2.value ? Number(areaM2.value) : 0,
      };
      const { data, error } = await sb.from('services')
        .update(payload).eq('id', currentService.id).select().single();
      if (error) { console.error(error); return toast('Erro ao salvar', 'err'); }
      currentService = data;
      toast('Alterações salvas', 'ok');
      refreshForm();
      await loadRequiredDocs();
      await loadMyServices();
    });

    btnSendDocs.addEventListener('click', async () => {
      if (!sb || !currentService?.id) return;

      // Percorre todos inputs file
      const inputs = docsList.querySelectorAll('input[type=file]');
      if (!inputs.length) return toast('Nenhum campo de upload disponível.', 'err');

      const bucket = sb.storage.from('pdfs');
      const uploads = [];

      inputs.forEach(inp => {
        const file = inp.files?.[0];
        if (!file) return; // apenas os selecionados
        if (file.type !== 'application/pdf') {
          return toast(`O arquivo "${file.name}" precisa ser PDF.`, 'err');
        }
        const docCode = inp.dataset.code; // veio do render
        const docId   = inp.dataset.docid;
        const path = `${CURRENT_COMPANY_ID}/${currentService.id}/${docCode}.pdf`;

        uploads.push(
          (async () => {
            const { error: upErr } = await bucket.upload(path, file, { upsert: true, contentType: 'application/pdf' });
            if (upErr) { console.error(upErr); throw upErr; }

            // registra (upsert) em service_documents
            const { error: dbErr } = await sb.from('service_documents')
              .upsert({
                service_id: currentService.id,
                document_type_id: docId,
                file_path: path,
                uploaded_at: new Date().toISOString()
              }, { onConflict: 'service_id,document_type_id' });
            if (dbErr) { console.error(dbErr); throw dbErr; }
          })()
        );
      });

      try {
        await Promise.all(uploads);
        toast('Uploads salvos', 'ok');
        await loadRequiredDocs(); // atualiza lista (para marcar enviados)
      } catch (e) {
        toast('Falha ao enviar algum documento', 'err');
      }
    });

    btnSubmit.addEventListener('click', async () => {
      if (!sb || !currentService?.id) return;

      // Poderíamos checar se todos documentos foram enviados; aqui deixo como opcional:
      // if (!todosDocsOk) return toast('Envie todos os documentos obrigatórios.', 'err');

      const { data, error } = await sb.from('services')
        .update({ status: 'under_review', updated_at: new Date().toISOString() })
        .eq('id', currentService.id).select().single();
      if (error) { console.error(error); return toast('Erro ao enviar para análise', 'err'); }
      currentService = data;
      toast('Enviado para análise', 'ok');
      refreshForm();
      await loadMyServices();
    });

    /*********************************
     * Funções de tela/dados
     *********************************/
    async function loadMyServices() {
      if (!sb) return;
      // junta info do tipo para exibir o nome
      const { data, error } = await sb
        .from('services')
        .select('id, status, protocol, created_at, service_types(name)')
        .order('created_at', { ascending: false });
      if (error) { console.error(error); return; }

      tbody.innerHTML = (data || []).map(s => `
        <tr>
          <td class="mono">${s.id}</td>
          <td>${s.service_types?.name || '-'}</td>
          <td>${statusLabel(s.status)}</td>
          <td class="mono">${s.protocol || '-'}</td>
          <td>${fmt.format(new Date(s.created_at))}</td>
          <td>
            <button class="secondary small" data-edit="${s.id}" ${!canEdit(s.status) ? 'disabled' : ''}>Editar</button>
          </td>
        </tr>
      `).join('');

      // ação editar
      tbody.querySelectorAll('button[data-edit]').forEach(btn => {
        btn.addEventListener('click', () => loadServiceById(btn.dataset.edit));
      });
    }

    function canEdit(status){
      return ['draft','corrections_requested'].includes(status);
    }

    async function loadServiceById(id){
      if (!sb) return;
      const { data, error } = await sb.from('services').select('*').eq('id', id).single();
      if (error) { console.error(error); return toast('Erro ao carregar serviço', 'err'); }
      currentService = data;
      refreshForm();
      await loadRequiredDocs();
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    function refreshForm(){
      if (!currentService) {
        btnSave.disabled = true;
        proto.value = ''; statusTxt.value = '';
        docsList.innerHTML = ''; cardDocs.style.display = 'none';
        cardForm.classList.remove('lock');
        return;
      }
      // Preenche campos
      selType.value   = currentService.type_id ?? '';
      ownerName.value = currentService.owner_name ?? '';
      ownerCpf.value  = currentService.owner_cpf ?? '';
      ownerAddr.value = currentService.owner_address ?? '';
      siteAddr.value  = currentService.site_address ?? '';
      areaM2.value    = Number(currentService.area_m2 ?? 0);
      proto.value     = currentService.protocol || '';
      statusTxt.value = currentService.status || '';

      // Controle de edição
      const editable = canEdit(currentService.status);
      btnSave.disabled = !editable;
      btnSendDocs.disabled = !editable;
      btnSubmit.disabled = !editable;
      cardForm.classList.toggle('lock', !editable);

      // habilita área de documentos quando houver serviço
      cardDocs.style.display = 'block';
    }

    async function loadRequiredDocs(){
      if (!sb || !currentService?.type_id) return;
      // tenta com alias; ajuste conforme seu nome de chave estrangeira
      // 1) se FK chama document_type_id:
      let sel = 'document_type_id, document_types:document_type_id ( id, name, code )';
      // 2) se sua relação já está nomeada, a linha acima funciona.
      const { data, error } = await sb
        .from('service_type_requirements')
        .select(sel)
        .eq('service_type_id', currentService.type_id);
      if (error) { console.error(error); return; }

      // quais já foram enviados?
      const { data: sent } = await sb
        .from('service_documents')
        .select('document_type_id, file_path, uploaded_at')
        .eq('service_id', currentService.id);

      requiredDocs = (data || []).map(r => ({
        id: r.document_types?.id || r.document_type_id,
        name: r.document_types?.name || '(sem nome)',
        code: r.document_types?.code || 'doc',
        sent: sent?.find(s => s.document_type_id === (r.document_types?.id || r.document_type_id)) || null
      }));

      // renderiza
      docsList.innerHTML = requiredDocs.map(d => `
        <article>
          <header class="grid grid-3" style="align-items:center;">
            <strong>${d.name}</strong>
            <span class="mono small muted">código: ${d.code}</span>
            <span>${d.sent ? '<span class="badge ok">enviado</span>' : '<span class="badge warn">pendente</span>'}</span>
          </header>
          <input type="file" accept="application/pdf" data-code="${d.code}" data-docid="${d.id}" ${!canEdit(currentService.status) ? 'disabled' : ''}/>
          ${d.sent ? `<small class="muted">Último envio: ${fmt.format(new Date(d.sent.uploaded_at))}</small>` : ''}
        </article>
      `).join('');
    }
  </script>
</body>
</html>
